<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width initial-scale=1"> <meta name="author" content="ikiApps LLC, 粋アプリ, d108(सोऽहम्)"> <meta name="description" content="There is a strong need to work with typical business logic operations in a platform-agnostic manner for increased code re-use, reduced dependencies, and high..."> <title>Rust as an App Language</title> <link href="/assets/themes/bootstrap/resources/bootstrap/css/bootstrap.min.css" rel="stylesheet"> <!--[if lt IE 9]> <script src="/assets/themes/bootstrap/resources/respond/Respond.min.js"></script> <![endif]--> <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed"> <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed"> <link rel="stylesheet" href="/css/main.css" type="text/css"> <link rel="canonical" href="/programming/2019/07/26/is-rust-good-for-apps"> <link rel="shortcut icon" href="/favicon.ico"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-40712418-2', 'auto'); ga('send', 'pageview'); </script> <script src="/js/jquery-3.2.0.min.js"></script> </head> <body> <nav class="navbar navbar-default" role="navigation"> <div class="container"> <div class="navbar-header"> <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <div class="navbar-image"><a href="/"><img src="/assets/themes/bootstrap/iki-circle-logo.png" width="40"/></a></div> <a class="navbar-brand" href="/">ikiApps</a> </div> <div class="collapse navbar-collapse navbar-ex1-collapse"> <ul class="nav navbar-nav"> <li><a href="/blog/">Blog</a></li> <li><a href="/archive">Archive</a></li> <li><a href="/tags">Tags</a></li> <li><a href="/search/">Search</a></li> </ul> </div> </div> </nav> <div class="container"> <div class="page-header"> <h1>Rust as an App Language <br/><small>A Brief Inspection of Implementing Business Logic for Shared Libraries</small></h1> </div> <div class="row post-full"> <div class="col-md-12"> <div class="date"> <span>Updated on 26 July 2019</span> </div> <div class="content"> <p>There is a strong need to work with typical business logic operations in a platform-agnostic manner for increased code re-use, reduced dependencies, and higher performance. Consider Rust. The language is a prime candidate for replacing C++, at large, as a systems language but can it also serve the needs of general consumer applications? This article is written for somebody interested in how Rust can be used by someone with experience in other modernized application programming languages like Swift and Kotlin.</p> <p>So is Rust good for handling business logic? Is it good as an app language?</p> <p>I’ve been using the DynamoDB API as a test bed with at least five or six languages now to accumulate data points for my evaluation. The reason behind this exploration is to converge on cohesive techniques for implementing multiplatform architecture based on shared libraries that can support a mostly functional, declarative style of programming.</p> <p>To be fair, I haven’t given equal consideration to Haskell or OCaml as I don’t have the requirement for a language to be as “purely” functional as they allow. My choices are not based solely on the language but rather the accompanying ecosystem, including community support and package availability. There is also an element of playing with new toys that is hopefully tempered by rational considerations.</p> <p>I’ll cover the following areas about Rust programming.</p> <ul> <li>The Rust type system</li> <li>Futures (synced and async polled)</li> <li>Iterators</li> <li>Mapping</li> <li>Closures</li> <li>Vec (array-like)</li> <li>HashMap</li> <li>Generics</li> <li>Unit testing</li> </ul> <p>Rust, with its implicit return values and unit type, is reminiscent of F# to me (without requiring a .NET runtime) while having the ability to control bare metal. This gives it awesome potential for performant functional-style programming. Given the choice between working with a functional, strongly typed, ML-derived, systems language versus an imperative, weaker typed, Algol-based one, the former has significant advantages when it comes to developing programs that can evolve over time. It is due to supporting more of a bottom-up approach through functional composition rather than one that is top-down via duck-typed class hierarchies.</p> <div style="width: 80%; margin-left: auto; margin-right: auto;"> <hr /> <img src="/img/2019-07-26-is-rust-good-for-apps/is-rust-good-for-apps.png" alt="Rust logo" width="50%" /> <hr /> </div> <h2 id="and-now-rust">And now Rust</h2> <p>After comparing many different languages and their ecosystems, I’m ready to give a little more time to Rust. A language should serve as a tool for what one wishes to express. Philosophically, Rust matches my preferences along with having the potential for high performance, runtime safety, and interoperability (via C bindings) with environments for other languages.</p> <p>While there is no official AWS SDK for Rust, the Rusoto project seems stable and comprehensive enough for real use. The examples herein make use of it where I have limited them to a single operation, deleting tables, because I found numerous ways to approach this single problem that led me on a path of learning. I’ll show how my individual functions evolved to fit my expanding requirements.</p> <p>The AWS DynamoDB API uses inputs and outputs. They are used similarly in the AWS SDKs for other platforms. For deleting a table, a delete <em>input</em> is made that is passed to the delete command. Upon execution, a delete <em>output</em> is available. This is what it looks like in Rust:</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">fn</span> <span class="nf">delete_table</span><span class="p">(</span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span>-&gt; <span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">table_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DeleteTableInput</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">table_name</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">client</span><span class="p">().</span><span class="n">delete_table</span><span class="p">(</span><span class="n">input</span><span class="p">).</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_output</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;deleted&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></code></pre></figure> <p>The sync indicates a thread-blocking operation. The underscore in front of output says I’m ignoring that value, for now. The delete table input creation is in shorthand form because there is a matching local <code>table_name</code> argument in name and type. The result gives a <code>Result&lt;DeleteTableOutput, RusotoError&lt;DeleteTableError&gt;&gt;</code>.</p> <p>In just a single function, one can get a feel of how explicit the type handling is under the Rust type system. There is some shortening of the need to specify everything through type inference but the compiler still treats each type strictly.</p> <p>To get started, I’m returning a tuple of strings consisting of the table name and a descriptive message. Due to ownership rules where a value can be moved among owners, the string reference (&amp;str) is converted to an opaque value when needed. String literals default to <code>&amp;str</code> instead of std:string::String. This may seem strange at first, but it ends up being a sensible choice given how ownership and borrowing work.</p> <h2 id="multiple-tables">Multiple tables</h2> <p>Now that one table can be deleted, the next logical step is be able to delete any number of tables. Perhaps, one of the most familiar ways is to use a for-in loop like so:</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">fn</span> <span class="nf">delete_tables_by_for_in</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">all_tables</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">delete_table</span><span class="p">(</span><span class="n">table</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></code></pre></figure> <p>In case loops are not desired, mapping also works and the results can be collected into a growable, array-like structure called a <code>Vec</code>.</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">fn</span> <span class="nf">delete_tables_by_map</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">deleted</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">        </span><span class="n">all_tables</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">delete_table</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">deleted</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></code></pre></figure> <p>Nothing too difficult there, right?</p> <h2 id="transitioning-to-asynchronous-polling">Transitioning to asynchronous polling</h2> <p>Blocking operations are good for testing but may not be sufficiently flexible for performance and user experience in production.</p> <p>The underlying type for these actions is <code>RusotoFuture.</code> It is an implementation of a futures::future::Future (distinct from a std::future::Future), a trait that contains the two associated types, Item and Error.</p> <p><a name="delete_table_future"></a> The delete table Future can be written as a function where the implementation is its return type:</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">fn</span> <span class="nf">delete_table_future</span><span class="p">(</span><span class="n">table_name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="n">DeleteTableOutput</span><span class="p">,</span><span class="w"> </span>
<span class="w">                   </span><span class="n">Error</span><span class="o">=</span><span class="n">RusotoError</span><span class="o">&lt;</span><span class="n">DeleteTableError</span><span class="o">&gt;&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">make_input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DeleteTableInput</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">table_name</span>: <span class="nc">table_name</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">client</span><span class="p">().</span><span class="n">delete_table</span><span class="p">(</span><span class="n">make_input</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></code></pre></figure> <p>Futures do not perform actions until polled. Therefore, this can be considered the declarative form of the previous imperative version that called sync().</p> <p>To use this, my first thought was to map the results into a Vec. I show a nonworking attempt below that is not compilable but shows what were my intentions.</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// 👎 Non-working attempt to run futures.</span>
<span class="k">fn</span> <span class="nf">nonworking_delete_tables_with_future_by_map</span><span class="p">()</span><span class="w"> </span>
<span class="w">    </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">DeleteTableOutput</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">all_tables</span><span class="p">().</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">delete_table_future</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">output</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">output</span><span class="w"></span>
<span class="w">        </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></code></pre></figure> <p>The idea was to collect the DeleteTableOutputs into a Vec. However, <code>map</code> was not successful for getting a Future to run. Instead, there is a runner in tokio_core::reactor::Core. It takes the future as an argument (passed by value, i.e. not a pointer).</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">fn</span> <span class="nf">run_delete_table_future</span><span class="p">(</span><span class="n">table_name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span>-&gt; <span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">RusotoError</span><span class="o">&lt;</span><span class="n">DeleteTableError</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">Core</span>::<span class="n">new</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">run</span><span class="p">(</span><span class="n">delete_table_future</span><span class="p">(</span><span class="n">table_name</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_item</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">table_name</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="nb">None</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">table_name</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">e</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></code></pre></figure> <p>I start to return the actual error (instead of a string) here as the second member of the return tuple. These tuples can be collected nicely into a HashMap where a delete table call function can now be written as:</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">fn</span> <span class="nf">tables_deleted</span><span class="p">()</span><span class="w"> </span>
<span class="w">    </span>-&gt; <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span>
<span class="w">               </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">RusotoError</span><span class="o">&lt;</span><span class="n">DeleteTableError</span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">all_tables</span><span class="p">().</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">run_delete_table_future</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}).</span><span class="n">collect</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></code></pre></figure> <p>Is that not more beautifully compact considering where we started? I think so, but there’s more that can be done.</p> <h2 id="generics---for-the-ability-to-repeat-yourself-less">Generics - For the ability to repeat yourself less</h2> <p>In a real app, there is a need to support large numbers of unique, but similar, DB operations. Do we have to make a separate runner for each one? Or is there a way to handle them generically? If the Future can be passed as a function parameter, then a single runner can be used for all of them, in general. The next function illustrates the result of reasoning out a way to make the runner more generic.</p> <p>Due to the contract in the Future trait, there’s a little, helpful path syntax that can be used to get to the error in anything that implements it. For example, if there’s a generic type U, U::Error gets the error. To start with, we’ll collect the errors from a generic future runner by letting our previous return type of DeleteOutputError be generically determined by placing the generic type in the return value position of the Future calling function reference that is passed in as an argument to the runner.</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">fn</span> <span class="nf">run_future_generically</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">some_future</span>: <span class="kp">&amp;</span><span class="nb">Fn</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">U</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">U</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">U</span>: <span class="nc">futures</span>::<span class="n">Future</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">Core</span>::<span class="n">new</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">run</span><span class="p">(</span><span class="n">some_future</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_item</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></code></pre></figure> <p>I’m having the runner return an Option through the pattern matching on the result of the Future. This is for convenience later to separate the operations that have errors. Setting the generic condition or constraint (trait bound), that U is a Future, ensures that only Errors from a Future will be returned. This seems like an enormous improvement to writing a separate runner for each DB operation, doesn’t it?</p> <p>It allows passing delete_table_future, or some other operation, directly into the runner where the runner, itself, only has to deal with an Item and an Error. That effectively provides all the benefits of separating responsibilities without requiring any hierarchical OOP structure (instead being interface-mediated behaviors) and it works for all the DB operations that can be represented as a Future.</p> <p>This is a <em>major turning point</em> in that the details of running each operation are no longer a separate implementation, or function, as they might be without generics. I can simply declare all behavior in the function that is passed in. If I just want to know delete table errors, then I can set that as the return type, as below.</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">fn</span> <span class="nf">tables_deleted_generically</span><span class="p">()</span><span class="w"> </span>
<span class="w">    </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">RusotoError</span><span class="o">&lt;</span><span class="n">DeleteTableError</span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">all_tables</span><span class="p">().</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">run_future_generically</span><span class="p">(</span><span class="o">&amp;||</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">delete_table_future</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></code></pre></figure> <p>For convenience, I’ve collected the errors into a Vec. What if we want to also have the DeleteTableOutput for knowing things like the table name according to my original returning of strings? From all the previous definitions, hopefully, it can be seen quite clearly how to do this.</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">fn</span> <span class="nf">tables_deleted_generically</span><span class="p">()</span><span class="w"> </span>
<span class="w">    </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">DeleteTableOutput</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">RusotoError</span><span class="o">&lt;</span><span class="n">DeleteTableError</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">all_tables</span><span class="p">().</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">run_future_generically</span><span class="p">(</span><span class="o">&amp;||</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">delete_table_future</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}).</span><span class="n">collect</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></code></pre></figure> <p>The return type is modified to include the Future output contained in its Item property. This change requires a little corresponding modification to the runner function.</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">fn</span> <span class="nf">run_future_generically</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">some_future</span>: <span class="kp">&amp;</span><span class="nb">Fn</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">U</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span>-&gt; <span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">U</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">U</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">U</span>: <span class="nc">futures</span>::<span class="n">Future</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">Core</span>::<span class="n">new</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">run</span><span class="p">(</span><span class="n">some_future</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">item</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">e</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></code></pre></figure> <p>In summary, along with being able to automatically handle the return type (via generics), there is no dependency on the size or shape of the Future that is passed in. This is possible because there are zero input arguments (arity 0) on <code>some_future</code> in the runner. 🎉 The implementation details are completely encapsulated in the closure reference to <a href="#delete_table_future">delete_table_future</a> 🎉.</p> <p>We now have the full result of any Future, wrapped in Options for convenience. Nearly any kind of operation can be performed on the DB, generically! This solution has been derived entirely through the algebra of types. Finally, evaluation of the results (such as for testing) can be accomplished by destructuring the Option pairs:</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="cp">#[test]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">test_generic_future_call</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">expect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">tables_deleted_generically</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">output</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">                </span><span class="p">{</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;❌ {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">table_description</span><span class="p">.</span><span class="n">unwrap</span><span class="p">().</span><span class="n">table_name</span><span class="p">.</span><span class="n">unwrap</span><span class="p">())</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">_e</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;⚠️&quot;</span><span class="p">);</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span><span class="w"> </span><span class="n">expect</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></code></pre></figure> <p>I test this using:</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span></span>$ cargo <span class="nb">test</span> --color<span class="o">=</span>always --package ddb_rust --test db_tests tests::test_generic_future_call -- --nocapture --exact</code></pre></figure> <p>with nocapture specified to allow output to stdout.</p> <p>For reference, the following dependencies were used for the previous examples with Rust 1.36.0 (2018 edition).</p> <figure class="highlight"><pre><code class="language-toml" data-lang="toml"><span></span><span class="p">[</span><span class="n">dependencies</span><span class="p">]</span>
<span class="n">rusoto_core</span> <span class="o">=</span> <span class="s">&quot;0.40.0&quot;</span>
<span class="n">rusoto_dynamodb</span> <span class="o">=</span> <span class="s">&quot;0.40.0&quot;</span>
<span class="n">futures</span> <span class="o">=</span> <span class="s">&quot;^0.1&quot;</span>
<span class="n">tokio-core</span> <span class="o">=</span> <span class="s">&quot;^0.1&quot;</span></code></pre></figure> <h2 id="conclusions">Conclusions</h2> <p>Deriving the functions that fulfill the requirements of this project consisted entirely of forming type relationships that satisfy the compiler. What we get is relatively deterministic runtime behavior that can be tested and verified with the opportunity to handle any errors. Is it, therefore, more efficient to write programs in Rust?</p> <p>Compared to a similar implementation in Go or C++, I’d argue that Rust provides an alternative that reduces overhead both upfront during implementation and in terms of maintenance over time. Regarding style, I was able to express nearly exactly what I wanted. This is <em>unlike Go,</em> where more effort is required by me to fit that language with what I want to express. I believe equivalent functions could be rendered with C++ templates but, perhaps, without nearly as much help from the compiler.<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></p> <p>There is a cost in arriving at the right level of abstraction when applying a bottom-up approach to any given problem. But my experience has indicated this can be successful way to develop a solution that can be readily extended as new requirements are formed, especially with respect to composing functions, or functional units.</p> <p>Rust aids this process, because we get inherently consistent runtime safety and behaviors due to the pervasive type system and explicit memory model. This benefit comes at little additional cost. In other words, once you can wrap your head around this programming style, Rust can offer major engineering advantages compared to the typical drawbacks of other languages and ecosystems.</p> <p>It’s interesting to note that most of the dependencies I’m using appear to be under active development. I’m happy to report that package management has been a seamless experience. This is likely due to the excellence of the Cargo crate system even though <code>Cargo.lock</code> seems breathtakingly long (due to Rusoto’s dependencies) for my small amount of code. However, I’m confident build optimizations will be available when I’m ready for them.</p> <p>In summary, Rust has:</p> <ul> <li>Great function re-usability and composability</li> <li>Outstanding capacity to express abstract types and relationships that are enforced by the compiler (unlike Go)</li> <li>Runtime safety assurances reinforced by the type system</li> <li>Bare-metal control features</li> <li>Polished dependency management (unlike C++)</li> <li>Built-in testing (unlike C++)</li> <li>Precise error messages during compilation</li> <li>Support for both functional and imperative programming styles</li> <li>A foreign function interface (FFI)</li> </ul> <p>Overall, writing Rust does not feel extremely different from any other modern programming language. A sufficient background in protocol oriented programming in Swift can be good preparation due to its type system having high compatibility with Rust’s Traits. With so much going for it, I predict that it can have an extraordinary future based on having a design that addresses some of the biggest problems in software engineering.</p> <p>Unfortunately, there is much software in the world not built to the same standard as what is produced by the Rust compiler. From inherently unsafe memory models that can lead to security breaches to more devastating errors that can result in loss of life, how software is built <em>matters.</em></p> <p>The primary effort in Rust, for me, is the algebra of static types. But I don’t see this as a barrier to adoption. Rather, it is about being willing to invest in the kind of process that I’ve shown. The stunning part is that this skill is transferable to other programming environments. Therefore, the potential dividends seem higher than the cost of learning. That kind of value seems <em>rare and wonderful</em> in a field that regularly evaluates the trade-offs in its available options.</p> <hr /> <div class="footnotes"> <ol> <li id="fn:1"> <p>C++ seems to have the capability to do just about anything that other languages can while, somehow, maintaining the style of mostly unmodern C syntax.&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p> </li> </ol> </div> </div> <ul class="tag_box inline"> <li><i class="icon-folder-open"></i></li> <li><a href="/categories#Programming-ref"> Programming <span>2</span> </a></li> </ul> <ul class="tag_box inline"> <li><i class="icon-tags"></i></li> <li><a href="/tags#rust-ref">rust <span>2</span></a></li> <li><a href="/tags#generics-ref">generics <span>1</span></a></li> <li><a href="/tags#c++-ref">c++ <span>3</span></a></li> <li><a href="/tags#golang-ref">golang <span>2</span></a></li> <li><a href="/tags#f#-ref">f# <span>3</span></a></li> </ul> <hr> <ul class="pagination"> <li class="prev"><a href="/software-architecture/2019/06/23/multiplatform-architecture-with-shared-libraries" title="Multiplatform Architecture">&larr; Previous</a></li> <li><a href="/archive">Archive</a></li> <li class="next disabled"><a>Next &rarr;</a> </ul> <hr> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_developer = 1; var disqus_shortname = 'ikiapps'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a> </div> </div> <hr/> <footer> <div style="float: left; margin-top: 10px; margin-bottom: 45px;"> &copy; 2019 ikiApps LLC</div> <div style="float: right; margin-top: 10px; margin-bottom: 40px;"><a href="/contact" target="_blank">Contact</a></div> <div style="float: left; margin-top: 10px; margin-bottom: 40px;"><hr/></div> </footer> </div> <script src="/assets/themes/bootstrap/resources/bootstrap/js/bootstrap.min.js"></script> </body> </html>
