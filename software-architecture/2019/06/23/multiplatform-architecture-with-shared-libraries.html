<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width initial-scale=1"> <meta name="author" content="ikiApps LLC, 粋アプリ, d108(सोऽहम्)"> <meta name="description" content=" Figure 1: An architecture based on shared libraries in a middleware layer (with an optional shared view model) to serve delivery of client apps t..."> <title>Multiplatform Architecture</title> <link href="/assets/themes/bootstrap/resources/bootstrap/css/bootstrap.min.css" rel="stylesheet"> <!--[if lt IE 9]> <script src="/assets/themes/bootstrap/resources/respond/Respond.min.js"></script> <![endif]--> <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed"> <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed"> <link rel="stylesheet" href="/css/main.css" type="text/css"> <link rel="canonical" href="/software-architecture/2019/06/23/multiplatform-architecture-with-shared-libraries"> <link rel="shortcut icon" href="/favicon.ico"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-40712418-2', 'auto'); ga('send', 'pageview'); </script> <script src="/js/jquery-3.2.0.min.js"></script> </head> <body> <nav class="navbar navbar-default" role="navigation"> <div class="container"> <div class="navbar-header"> <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <div class="navbar-image"><a href="/"><img src="/assets/themes/bootstrap/iki-circle-logo.png" width="40"/></a></div> <a class="navbar-brand" href="/">ikiApps</a> </div> <div class="collapse navbar-collapse navbar-ex1-collapse"> <ul class="nav navbar-nav"> <li><a href="/blog/">Blog</a></li> <li><a href="/archive">Archive</a></li> <li><a href="/tags">Tags</a></li> <li><a href="/search/">Search</a></li> </ul> </div> </div> </nav> <div class="container"> <div class="page-header"> <h1>Multiplatform Architecture <br/><small>Shared Libraries for More Effective Code-Reuse and Faster Time to Market</small></h1> </div> <div class="row post-full"> <div class="col-md-12"> <div class="date"> <span>Updated on 30 June 2019</span> </div> <div class="content"> <p> <figure class="image"><img src="/img/2019-06-23-multiplatform-architecture-with-shared-libraries/multiplatform-architecture-diagram-2.png" alt="Figure 1: An architecture based on shared libraries in a middleware layer (with an optional shared view model) to serve delivery of client apps to multiple native platform targets." /> <figcaption><strong>Figure 1: An architecture based on shared libraries in a middleware layer (with an optional shared view model) to serve delivery of client apps to multiple native platform targets.</strong> </figcaption> </figure> </p> <p>Reaching users is a quintessential way of growing technology products. Time to market efficiency is a vital consideration for a business seeking to validate new ideas.</p> <p>For consumer apps, that means making versions quickly available on a diversity of major target platforms such as:</p> <ul> <li>Android</li> <li>iOS/iPadOS/watchOS</li> <li>Windows</li> <li>The Web</li> <li>macOS</li> </ul> <h2 id="shared-libraries-as-a-middleware-foundation">Shared libraries as a middleware foundation</h2> <p>There are various ways to go about delivering solutions to multiple platforms efficiently. I want to highlight an architecture based on shared libraries, situated in a middleware role between backend services and native clients, as one strategy to consider when seeking the following advantages:</p> <ul> <li>Code re-use at the data model handling and business logic level.</li> <li>Serve a preference for a single programming language or a set of languages.</li> <li>Freedom from target platform constraints through effective dependency handling.</li> <li>Plays nice with backend resources.</li> <li>Supports a workflow conducive to overall productivity.</li> </ul> <h2 id="requirements-of-shared-libraries">Requirements of shared libraries</h2> <p>In choosing what technologies to invest in, there are several factors to consider. These can include:</p> <ul> <li>The capability for implementing most business logic with sufficient expressiveness and desired style.</li> <li>Having an API surface sufficient for native platform interfacing with the right balance of embeddability (access to language features and packages) and performance (memory and processing).</li> <li>Being free of interoperability restrictions, either technical or political in nature.</li> </ul> <p>While I am considering this architecture in general terms, the target platform tending to have the most restrictions is iOS. Therefore, much of my evaluation is based on how well a chosen foundation can be integrated with that operating system.</p> <h2 id="programming-language-options">Programming language options</h2> <p>When it comes to writing code, a programming language sets the stage for what can be expressed. We all have our individual preferences and they are an important factor to consider for both reasons of style and productivity. In a shared library situation, there are additional concerns of interoperability and package availability to extend base language functionality, as needed.</p> <p>Some possible languages for generating multiplatform shared libraries are:</p> <ul> <li>C</li> <li>C++</li> <li>JavaScript</li> <li>Swift</li> <li>Kotlin (generate with Kotlin/Native)</li> <li>C#/F# (generate with .NET Embedding)</li> <li>Rust</li> <li>Go (aka golang) (generate with Go on Mobile)</li> </ul> <p>C is one of the most portable languages but without much support for modern programming paradigms. C++ seems capable of doing just about anything but has a style and complexity that is not for everyone. This situation continues to evolve with further iterations of the language. However, in scenarios where undisputed control over system resources is needed, C/C++ are prime choices.</p> <p>JavaScript is a surprisingly powerful language with regard to expressiveness especially in terms of functional programming. Being not compiled by default means that it generally requires a runtime engine. That is a constraint that can hinder its effectiveness with regard to interoperability.</p> <p>Swift may not be considered as a contender by those outside of the Apple ecosystem. Being aligned with one of the most restrictive platforms is something that may be a major drawback when it comes to filling a multiplatform role. Also, package availability may not be nearly as expansive as in other ecosystems.</p> <p>Kotlin takes the next step by offering compilation of its code to native libraries via Kotlin/Native. One of its best features, interoperability with Java, <em>may also be one of its worst,</em> in terms of overall potential as a multiplatform language. This is due to decreased incentive for package creators to deliver pure Kotlin editions when there is a Java version available and that Kotlin/Native is not able to import Java.</p> <p>C#/F# has a heavy association with Windows and that might be a turn-off for those unaware of .NET’s new open-source direction. With .NET Embedding, these languages may provide the right level of expressiveness along with embeddability and utility matched by one of the richest software ecosystems in the world.</p> <p>Finally, when it comes to finding the right blend of performance and expressivity, Go (golang) and Rust may be the ideal candidates due to having the much of the control of C/C++, by virtue of being systems-level languages, with a more modern, refined (less-encumbered) approach. Between the two, Go seems to be more opinionated in its idioms, while Rust offers support for a greater variety of programming styles.</p> <h2 id="further-considerations">Further considerations</h2> <p>Ideally, what is wanted is modern expressiveness, high performance, and significant community support on multiple platforms where choosing a language doesn’t require trading capability for convenience or declaring allegiance to a corporate monopoly. In reality, there are numerous trade-offs for any given choice, or set thereof, such as the following concerns:</p> <ul> <li>Programmer abilities</li> <li>Memory requirements</li> <li>Computational performance</li> <li>Interoperability overhead</li> <li>Threading-model compatibility</li> <li>Garbage collecting needs</li> <li>Types to be exchanged</li> <li>Exception handling</li> <li>Package import limitations</li> <li>CPU optimizations</li> <li>Code expressiveness</li> <li>Platform restrictions</li> </ul> <h2 id="evaluating-the-choices">Evaluating the choices</h2> <p>One way to go about evaluating these options is to implement a project suitable to representing actual usage in each language. To that end, I created a sample project for my candidates where the goal was to produce a multiplatform compatible library capable of performing create, read, update and delete (CRUD) operations on DynamoDB that <strong>can be natively called from all of my target platforms.</strong></p> <h2 id="conclusions-tentative">Conclusions (tentative)</h2> <p>The hard work to gain the necessary experience with multiple language options for shared libraries is something that each engineer must do for themselves to be able to make a meaningful comparison according to their capabilities and preferences.</p> <p>My findings indicate that only compiled solutions are feasible for my requirements of performance, portability and increased freedom from additional runtime dependencies. Sorry, JavaScript, I don’t have an engine for you to run on.</p> <p>In summary, there are additional considerations to take into account such as:</p> <ul> <li>Management of additional compilation steps (e.g. JIT or AOT)</li> <li>Supporting ecosystem (especially the availability of packages/libraries)</li> <li>Interoperability with existing environment</li> <li>Programming style (not to be underestimated)</li> </ul> <p>Having evaluated C#, Kotlin (with Java), C++, Rust and Go (golang), my tentative conclusion is that all are potentially viable to serve as the language foundation for a shared library approach to multiplatform architecture. There are some limitations that will be deciding factors during actual project execution.</p> <p>Choosing compiled solutions is still not a binary decision when it comes to adjusting to the nuances of multiplatform interoperability. For example, with .NET, the compiler produces an intermediate compilation that can be fed into a JIT compiler. From there, native code can be generated. In other words, there’s much more going on between the source and the final compiled product. There were also Xamarin dependencies that I found to be an issue when wishing to test with NUnit.</p> <p>Sometime in the future, .NET Embedding (Embeddinator-4000) may present itself as an ideal multiplatform library generator. This is due in no small part to the large collection of libraries that can extend a C#/F# implementation. However, this technology does not yet seem to be ready for general use, lacking such features as complete debugging and additional work required to manage the Mono framework linked to host apps.<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></p> <p>On the Java side, particularly impacting non-JVM environments like iOS, Java-based libraries are not available to Kotlin/Native. This is a major limitation that negates much of its usefulness in a general purpose shared library role even though it may still be a much improved way to work with Java. Being a first-class Android language is also a strong factor to weigh in its favor.</p> <p>For the present, C++ is probably still the tried and true favorite with regard to interoperability and performance. But, alas, it is a language weighed down heavily by its roots and requires programming in a way much different from other modern languages.</p> <p>Go (golang) can be considered an improvement over some of those limitations in C++. I’m still evaluating its interoperation capabilities. Provisionally, the ability to produce iOS frameworks via “Go Mobile” or “Go on Mobile” seems promising and it may become the leader with regard to my preferences for a multiplatform library generator. It may be easier to interoperate with Go than Rust.</p> <p>There is growing support for multiplatform approaches among most major programming language ecosystems. Aside from C/C++, multiplatform library generators like Kotlin/Native, .NET Embedding and Go Mobile still have ground to cover before being production-quality solutions. If you are ready to take the plunge into a general multiplatform shared library architecture, C++ is probably the safest choice with Rust and Go (golang) being the next most promising options from my perspective.</p> <hr /> <div class="footnotes"> <ol> <li id="fn:1"> <p>As of 2019-11-10, I would not consider .NET Embedding (aka the Embeddinator project) to be suitable for production use due to lack of active development. See <a href="https://docs.microsoft.com/en-us/xamarin/tools/dotnet-embedding/release-notes/preview/0.4">.NET Embedding 0.4 release notes</a> corresponding to the last release on 2017-04-18.&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p> </li> </ol> </div> </div> <ul class="tag_box inline"> <li><i class="icon-folder-open"></i></li> <li><a href="/categories#Software-Architecture-ref"> Software-Architecture <span>1</span> </a></li> </ul> <ul class="tag_box inline"> <li><i class="icon-tags"></i></li> <li><a href="/tags#software-architecture-ref">software-architecture <span>1</span></a></li> <li><a href="/tags#c-ref">c <span>1</span></a></li> <li><a href="/tags#c++-ref">c++ <span>3</span></a></li> <li><a href="/tags#golang-ref">golang <span>2</span></a></li> <li><a href="/tags#rust-ref">rust <span>2</span></a></li> <li><a href="/tags#kotlin-ref">kotlin <span>2</span></a></li> <li><a href="/tags#java-ref">java <span>1</span></a></li> <li><a href="/tags#swift-ref">swift <span>12</span></a></li> <li><a href="/tags#c#-ref">c# <span>1</span></a></li> <li><a href="/tags#f#-ref">f# <span>3</span></a></li> <li><a href="/tags#javascript-ref">javascript <span>1</span></a></li> </ul> <hr> <ul class="pagination"> <li class="prev"><a href="/programming/2019/05/29/kotlin-json-processing" title="Kotlin for Concise JSON Pre-Processing">&larr; Previous</a></li> <li><a href="/archive">Archive</a></li> <li class="next"><a href="/programming/2019/07/26/is-rust-good-for-apps" title="Rust as an App Language">Next &rarr;</a></li> </ul> <hr> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_developer = 1; var disqus_shortname = 'ikiapps'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a> </div> </div> <hr/> <footer> <div style="float: left; margin-top: 10px; margin-bottom: 45px;"> &copy; 2019 ikiApps LLC</div> <div style="float: right; margin-top: 10px; margin-bottom: 40px;"><a href="/contact" target="_blank">Contact</a></div> <div style="float: left; margin-top: 10px; margin-bottom: 40px;"><hr/></div> </footer> </div> <script src="/assets/themes/bootstrap/resources/bootstrap/js/bootstrap.min.js"></script> </body> </html>
