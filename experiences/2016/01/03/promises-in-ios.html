<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width initial-scale=1"> <meta name="author" content="ikiApps LLC, 粋アプリ, d108(सोऽहम्)"> <meta name="description" content="There’s a certain tedium in implementing asynchronous operations using the typical patterns common in apps. Typically every call requires a completion handle..."> <title>My First Peek at Promises in Swift on iOS and OS X</title> <link href="/assets/themes/bootstrap/resources/bootstrap/css/bootstrap.min.css" rel="stylesheet"> <!--[if lt IE 9]> <script src="/assets/themes/bootstrap/resources/respond/Respond.min.js"></script> <![endif]--> <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed"> <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed"> <link rel="stylesheet" href="/css/main.css" type="text/css"> <link rel="canonical" href="/experiences/2016/01/03/promises-in-ios"> <link rel="shortcut icon" href="/favicon.ico"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-40712418-2', 'auto'); ga('send', 'pageview'); </script> <script src="/js/jquery-3.2.0.min.js"></script> </head> <body> <nav class="navbar navbar-default" role="navigation"> <div class="container"> <div class="navbar-header"> <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <div class="navbar-image"><a href="/"><img src="/assets/themes/bootstrap/iki-circle-logo.png" width="40"/></a></div> <a class="navbar-brand" href="/">ikiApps</a> </div> <div class="collapse navbar-collapse navbar-ex1-collapse"> <ul class="nav navbar-nav"> <li><a href="/blog/">Blog</a></li> <li><a href="/archive">Archive</a></li> <li><a href="/tags">Tags</a></li> <li><a href="/search/">Search</a></li> </ul> </div> </div> </nav> <div class="container"> <div class="page-header"> <h1>My First Peek at Promises in Swift on iOS and OS X </h1> </div> <div class="row post-full"> <div class="col-md-12"> <div class="date"> <span>03 January 2016</span> </div> <div class="content"> <p>There’s a certain tedium in implementing asynchronous operations using the typical patterns common in apps. Typically every call requires a completion handler that either handles the result or handles an error.</p> <p>I’ve taken a look at <a href="http://promisekit.org">PromiseKit 3.0.0</a> as a potential means to reduce some of that effort due to the following advantages</p> <ul> <li>escape from callback hells</li> <li>treat async values almost like synchronous values</li> <li>reduce cognitive overhead in implementing async operations</li> </ul> <p>The essence of promises is that they turn asynchronous operations into function-like entities. The return value is obtained by <code>then</code>ing a promise. The following code shows the definition of a promise based on a typical async operation and how the result from that async operation is obtained from the promise.</p> <figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span></span><span class="c1">// Sample Promise function form that wraps an existing async op.</span>
<span class="kd">func</span> <span class="nf">somePromise</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Promise</span><span class="p">&lt;</span><span class="bp">NSData</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Promise</span> <span class="p">{</span> <span class="n">fulfill</span><span class="p">,</span> <span class="n">reject</span> <span class="k">in</span>
        <span class="n">asyncOperationWithCompletion</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>			
            <span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="n">reject</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
            <span class="p">}</span>	
                <span class="n">fulfill</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">somePromise</span><span class="p">().</span><span class="n">then</span> <span class="p">{</span> <span class="n">data</span> <span class="k">in</span>
    <span class="c1">// Do something with the data retrieved from the Promise.</span>
<span class="p">}</span></code></pre></figure> <p>As an important note, the async code is executed at the time the Promise function is called. Therefore, the result could be retrieved by <code>then</code>ing the Promise when it is needed. In PromiseKit, there is even a <code>when</code> to allow actions to be taken as soon as the result is ready.</p> <h2 id="chaining-promises">Chaining Promises</h2> <p>Instead of descending into a callback chain to perform multiple dependent operations, a Promise chain can be created in a function compositional way. The result of each Promise in this example is passed on to be ingested by the next Promise.</p> <figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span></span><span class="n">firstly</span> <span class="p">{</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Promise</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">somePromise</span><span class="p">()</span> 
<span class="p">}.</span><span class="n">then</span> <span class="p">{</span> <span class="n">someResult</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">anotherPromise</span><span class="p">(</span><span class="n">someResult</span><span class="p">)</span> 
<span class="p">}.</span><span class="n">then</span> <span class="p">{</span> <span class="n">anotherResult</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">anotherPromiseAfterThat</span><span class="p">(</span><span class="n">anotherResult</span><span class="p">)</span>
<span class="p">}.</span><span class="n">then</span> <span class="p">{</span> <span class="n">anotherResultAfterThat</span> <span class="k">in</span>
    <span class="c1">// Do something with the final result of the Promise chain.</span>
<span class="p">}.</span><span class="n">error</span> <span class="p">{</span>
    <span class="c1">// Handle an error somewhere in the chain.</span>
<span class="p">}</span></code></pre></figure> <blockquote> <p>WARNING: The documentation at promisekit.org may refer to <code>.catch</code>. This has been replaced by <code>.error</code> in Swift. Every place that you see <code>.catch</code>, <code>.error</code> should be used instead.</p> </blockquote> <p>The Swift generic definition of a Promise as <code>Promise&lt;T&gt;</code> provides for a clear way of documenting return types such as <code>Promise&lt;String&gt;</code> directly within code.</p> <h2 id="chaining-async-calls-with-completion-handlers">Chaining async calls with completion handlers</h2> <p>A corresponding callback hell, I mean chain, would look something like</p> <figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span></span><span class="n">someFunction</span><span class="p">(</span><span class="n">completion</span><span class="p">:</span> <span class="p">{</span> <span class="n">someResult</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">error</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="n">anotherFunction</span><span class="p">(</span><span class="n">someResult</span><span class="p">,</span> <span class="n">completion</span><span class="p">:</span> <span class="p">{</span> <span class="n">anotherResult</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span> 
            <span class="k">if</span> <span class="n">error</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="n">anotherFunctionAfterThat</span><span class="p">(</span><span class="n">anotherResult</span><span class="p">,</span> <span class="n">completion</span><span class="p">:</span> <span class="p">{</span> <span class="n">anotherResultAfterThat</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
                    <span class="k">if</span> <span class="n">error</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span>
                        <span class="c1">// Do something with the final result of the completion chain.</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// Handle the error from anotherFunctionAfterThat.</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// Handle the error from anotherFunction.</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Handle the error from someFunction.</span>
    <span class="p">}</span>
<span class="p">})</span></code></pre></figure> <p>Really, it’s the error handling that explodes the callback chain. PromiseKit abstracts that error handling mess away into a single <code>.error</code> call.</p> <h2 id="summary">Summary</h2> <p>PromiseKit may seem like a solution without a problem since you can get to the same end result without it. It could be a solution if you consider meaningful, readable code to be a problem worth solving.</p> <p>The abstraction benefits that using the Promise type provides makes sense to me. It allows for keeping the logically related components of asynchronous operations together instead of split apart as with the callback form. A flat <code>then</code> chain is immediately preferable to a nested callback hell.</p> <p>In Swift, the implementation of promises by PromiseKit is elegant in how it integrates with the language. The benefits are visibly apparent within my simple examples.</p> <p>Aesthetics are not the only benefit. I also look forward to the effort that can be saved from not having to trace through compound callback mires during development and maintenance of my code.</p> <p>My conclusion is that promises can bring clarity to the handling of asynchronous operations in Swift in a way that improves our ability to create great user experiences in apps.</p> </div> <ul class="tag_box inline"> <li><i class="icon-folder-open"></i></li> <li><a href="/categories#experiences-ref"> experiences <span>6</span> </a></li> </ul> <ul class="tag_box inline"> <li><i class="icon-tags"></i></li> <li><a href="/tags#promise-ref">promise <span>1</span></a></li> <li><a href="/tags#swift-ref">swift <span>12</span></a></li> <li><a href="/tags#ios-ref">ios <span>9</span></a></li> <li><a href="/tags#osx-ref">osx <span>8</span></a></li> <li><a href="/tags#concurrency-ref">concurrency <span>3</span></a></li> <li><a href="/tags#asynchronous-operations-ref">asynchronous-operations <span>4</span></a></li> </ul> <hr> <ul class="pagination"> <li class="prev"><a href="/tips/2016/01/02/talking-through-delegation" title="Talking Through Delegates and Protocols for iOS and OS X">&larr; Previous</a></li> <li><a href="/archive">Archive</a></li> <li class="next"><a href="/experiences/2016/01/06/rac4-concurrency-lesson" title="ReactiveCocoa 4 Signals Teach Us an Important Lesson About Concurrency">Next &rarr;</a></li> </ul> <hr> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_developer = 1; var disqus_shortname = 'ikiapps'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a> </div> </div> <hr/> <footer> <div style="float: left; margin-top: 10px; margin-bottom: 45px;"> &copy; 2019 ikiApps LLC</div> <div style="float: right; margin-top: 10px; margin-bottom: 40px;"><a href="/contact" target="_blank">Contact</a></div> <div style="float: left; margin-top: 10px; margin-bottom: 40px;"><hr/></div> </footer> </div> <script src="/assets/themes/bootstrap/resources/bootstrap/js/bootstrap.min.js"></script> </body> </html>
