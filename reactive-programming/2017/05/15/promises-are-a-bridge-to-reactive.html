<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width initial-scale=1"> <meta name="author" content="ikiApps LLC, 粋アプリ, d108(सोऽहम्)"> <meta name="description" content=" Figure 1: A bridge is something that helps you get from one place of understanding to another. "> <title>Chaining Reactive Operations versus Promise Chains</title> <link href="/assets/themes/bootstrap/resources/bootstrap/css/bootstrap.min.css" rel="stylesheet"> <!--[if lt IE 9]> <script src="/assets/themes/bootstrap/resources/respond/Respond.min.js"></script> <![endif]--> <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed"> <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed"> <link rel="stylesheet" href="/css/main.css" type="text/css"> <link rel="canonical" href="/reactive-programming/2017/05/15/promises-are-a-bridge-to-reactive"> <link rel="shortcut icon" href="/favicon.ico"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-40712418-2', 'auto'); ga('send', 'pageview'); </script> <script src="/js/jquery-3.2.0.min.js"></script> </head> <body> <nav class="navbar navbar-default" role="navigation"> <div class="container"> <div class="navbar-header"> <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <div class="navbar-image"><a href="/"><img src="/assets/themes/bootstrap/iki-circle-logo.png" width="40"/></a></div> <a class="navbar-brand" href="/">ikiApps</a> </div> <div class="collapse navbar-collapse navbar-ex1-collapse"> <ul class="nav navbar-nav"> <li><a href="/blog/">Blog</a></li> <li><a href="/archive">Archive</a></li> <li><a href="/tags">Tags</a></li> <li><a href="/search/">Search</a></li> </ul> </div> </div> </nav> <div class="container"> <div class="page-header"> <h1>Chaining Reactive Operations versus Promise Chains <br/><small>Promises are a Bridge to Programming with Reactive Extensions</small></h1> </div> <div class="row post-full"> <div class="col-md-12"> <div class="date"> <span>Updated on 02 June 2017</span> </div> <div class="content"> <p> <figure class="image"><img src="/img/2017-05-15-promises-are-a-bridge-to-reactive/bridge-over-water.png" alt="Figure 1: A bridge is something that helps you get from one place of understanding to another." /> <figcaption><strong>Figure 1: A bridge is something that helps you get from one place of understanding to another.</strong> </figcaption> </figure> </p> <p>In my journey, I crossed the bridge of promises/futures and started construction of a new castle in the enchanted land of reactive extensions. Previous attempts to make the transition from the imperative world were not as successful before that bridge was established. Instead, the traversing of rough waters was required any time I wanted to visit the other side. It was that bridge that allowed the easy back and forth passage between imperative and reactive in the kingdom of Swift (v3.1).</p> <p>To those familiar with the mind bending struggle in going from ingrained imperative thought processes to the more declarative, reactive side of programming, I can only suggest that <strong>promises/futures may be the intermediate stepping stone that will get you across.</strong></p> <p>Promises provide a subset of the functionality found in programming with reactive extensions (Rx). In many cases, they are all you need to control multiple asynchronous operations. For the case of creating serverless functions for something like AWS Lambda, they can be the perfect tool in Node.js.</p> <h2 id="a-common-problem-get-prerequisite-data-for-an-asynchronous-operation">A common problem: Get prerequisite data for an asynchronous operation</h2> <p>The problem is how to obtain user data, without using fixed storage like a property, prior to performing an operation with the data?</p> <p>The pattern using promises is to chain an operation obtaining the needed data to a second operation that uses the data. Order is guaranteed by virtue of the serialization that is inherent to promises. This pattern can be equally implemented using Rx. By showing how this is done, my aim is to bridge your understanding of promises into Rx.</p> <p>The Promise library I’m using is <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a> and the Rx library is <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a>.</p> <p><strong>I have a new version of Calendar Timer 2 under development and I’m going to use actual code from my project.</strong> Since I’m using a database on Firebase, the code is also going to be tailored to that platform. The general differences between promises and reactive extensions, however, apply to many platforms and languages.</p> <h2 id="the-promise-chaining-solution">The Promise chaining solution</h2> <p>In the following code, I have generated the solution using a promise chain. I create a new Promise to hold the result of a unique ID that corresponds to a user-generated timed session configuration or <code>SessionConfigID</code>. I first need to get the user’s ID before I can save the data for the user. This is obtained from another Promise (line 10).</p> <p>Once I have the prerequisite data, I call <code>setValue</code> (line 20) on a Firebase database reference to save the model object for the session configuration. The errors are handled by failing the promise. Upon success, the unique key that is generated using Firebase is returned by the Promise (line 23).</p> <figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span></span><span class="lineno"> 1 </span><span class="c1">/// Save the session to the database for the current user.</span>
<span class="lineno"> 2 </span><span class="kd">func</span> <span class="nf">save</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Promise</span><span class="p">&lt;</span><span class="n">SessionConfigID</span><span class="p">?</span><span class="o">&gt;</span>
<span class="lineno"> 3 </span><span class="p">{</span>
<span class="lineno"> 4 </span>    <span class="kd">let</span> <span class="nv">users</span>   <span class="p">=</span> <span class="n">FirebasePath</span><span class="p">.</span><span class="n">users</span><span class="p">.</span><span class="n">rawValue</span>
<span class="lineno"> 5 </span>    <span class="kd">let</span> <span class="nv">configs</span> <span class="p">=</span> <span class="n">FirebasePath</span><span class="p">.</span><span class="n">sessionConfigs</span><span class="p">.</span><span class="n">rawValue</span>
<span class="lineno"> 6 </span>    <span class="kd">let</span> <span class="nv">prefix</span>  <span class="p">=</span> <span class="n">FirebasePrefix</span><span class="p">.</span><span class="n">sessionConfigs</span><span class="p">.</span><span class="n">rawValue</span>
<span class="lineno"> 7 </span>
<span class="lineno"> 8 </span>    <span class="k">return</span> <span class="n">Promise</span> <span class="p">{</span> <span class="n">send</span><span class="p">,</span> <span class="n">fail</span> <span class="k">in</span>
<span class="lineno"> 9 </span>        <span class="n">firstly</span> <span class="p">{</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Promise</span><span class="p">&lt;</span><span class="n">UserID</span><span class="p">?</span><span class="o">&gt;</span> <span class="k">in</span>
<span class="lineno">10 </span>            <span class="k">return</span> <span class="n">FirebaseUserStore</span><span class="p">.</span><span class="n">getCurrentUserID</span><span class="p">()</span>
<span class="lineno">11 </span>        <span class="p">}.</span><span class="n">then</span> <span class="p">{</span> <span class="p">(</span><span class="n">userID</span><span class="p">:</span> <span class="n">UserID</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="p">()</span> <span class="k">in</span>
<span class="lineno">12 </span>            <span class="k">guard</span> <span class="kd">let</span> <span class="nv">uwUID</span> <span class="p">=</span> <span class="n">userID</span> <span class="k">else</span> <span class="p">{</span>
<span class="lineno">13 </span>                <span class="n">fail</span><span class="p">(</span><span class="n">FirebaseError</span><span class="p">.</span><span class="n">userIDMissingError</span><span class="p">)</span>
<span class="lineno">14 </span>                <span class="k">return</span>
<span class="lineno">15 </span>            <span class="p">}</span>
<span class="lineno">16 </span>            <span class="kd">let</span> <span class="p">(</span><span class="n">dref</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">dbRefWithKey</span><span class="p">(</span><span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="n">users</span><span class="p">,</span> <span class="n">uwUID</span><span class="p">,</span> <span class="n">configs</span><span class="p">],</span>
<span class="lineno">17 </span>                                                <span class="kr">prefix</span><span class="p">:</span> <span class="kr">prefix</span><span class="p">)</span>
<span class="lineno">18 </span>            <span class="n">dref</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">toFirebase</span><span class="p">(),</span>
<span class="lineno">19 </span>                          <span class="n">withCompletionBlock</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="k">in</span>
<span class="lineno">20 </span>                <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="n">fail</span><span class="p">(</span><span class="n">err</span><span class="p">!)</span> <span class="p">}</span>
<span class="lineno">21 </span>                <span class="k">else</span> <span class="p">{</span> <span class="n">send</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">}</span>
<span class="lineno">22 </span>            <span class="p">})</span>
<span class="lineno">23 </span>        <span class="p">}.</span><span class="k">catch</span> <span class="p">{</span> <span class="n">err</span> <span class="k">in</span>
<span class="lineno">24 </span>            <span class="c1">// The error handling here feels awkward and redundant</span>
<span class="lineno">25 </span>            <span class="c1">// but it is required by the promise pattern.</span>
<span class="lineno">26 </span>            <span class="n">fail</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="lineno">27 </span>        <span class="p">}</span>
<span class="lineno">28 </span>    <span class="p">}</span>
<span class="lineno">29 </span><span class="p">}</span></code></pre></figure> <p>With promises, there is really only one way to combine operations and that is in a serial chain. On the other hand, reactive extensions offer a much greater set of options. However, for the purpose of comparison I’m going to limit my example to performing the equivalent operations of a promise chain.</p> <h2 id="the-observable-chaining-solution">The Observable chaining solution</h2> <p>I create a function that returns an Observable of a user’s sessionconfiguration ID that identifies a custom model object used to storeuser data. I first need the user’s ID to be able to save a user created session configuration. In my code, this is handled by an Observable assigned to <code>uidObs</code>. With reactive extensions, <strong><code>flatMap</code> is the chaining tool that allows you to chain the results of one observableinto another.</strong> See <strong>Figure 2</strong> for a diagram to help you visualize what happens with observables during a flatMap. Once I have the user ID, I pass it into the Observable that returns the <code>SessionConfigID</code> (line22).</p> <figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span></span><span class="lineno"> 1 </span><span class="c1">/// Save the session to the database for the current user.</span>
<span class="lineno"> 2 </span><span class="kd">func</span> <span class="nf">save</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Observable</span><span class="p">&lt;</span><span class="n">SessionConfigID</span><span class="p">?</span><span class="o">&gt;</span>
<span class="lineno"> 3 </span><span class="p">{</span>
<span class="lineno"> 4 </span>    <span class="kd">let</span> <span class="nv">users</span>   <span class="p">=</span> <span class="n">FirebasePath</span><span class="p">.</span><span class="n">users</span><span class="p">.</span><span class="n">rawValue</span>
<span class="lineno"> 5 </span>    <span class="kd">let</span> <span class="nv">configs</span> <span class="p">=</span> <span class="n">FirebasePath</span><span class="p">.</span><span class="n">sessionConfigs</span><span class="p">.</span><span class="n">rawValue</span>
<span class="lineno"> 6 </span>    <span class="kd">let</span> <span class="nv">prefix</span>  <span class="p">=</span> <span class="n">FirebasePrefix</span><span class="p">.</span><span class="n">sessionConfigs</span><span class="p">.</span><span class="n">rawValue</span>
<span class="lineno"> 7 </span>    <span class="kd">let</span> <span class="nv">uidObs</span>  <span class="p">=</span> <span class="n">FirebaseUserStore</span><span class="p">.</span><span class="n">currentUserID</span><span class="p">()</span>
<span class="lineno"> 8 </span>
<span class="lineno"> 9 </span>    <span class="k">return</span> <span class="n">uidObs</span><span class="p">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">uid</span> <span class="p">-&gt;</span> <span class="n">Observable</span><span class="p">&lt;</span><span class="n">SessionConfigID</span><span class="p">?</span><span class="o">&gt;</span> <span class="k">in</span>
<span class="lineno">10 </span>        <span class="k">return</span> <span class="n">Observable</span><span class="p">.</span><span class="n">create</span> <span class="p">{</span> <span class="n">observer</span> <span class="k">in</span>
<span class="lineno">11 </span>            <span class="k">guard</span> <span class="kd">let</span> <span class="nv">uwUID</span> <span class="p">=</span> <span class="n">uid</span> <span class="k">else</span> <span class="p">{</span>
<span class="lineno">12 </span>                <span class="n">observer</span><span class="p">.</span><span class="n">onError</span><span class="p">(</span><span class="n">FirebaseError</span><span class="p">.</span><span class="n">userIDMissingError</span><span class="p">)</span>
<span class="lineno">13 </span>                <span class="k">return</span> <span class="n">Disposables</span><span class="p">.</span><span class="n">create</span><span class="p">()</span>
<span class="lineno">14 </span>            <span class="p">}</span>
<span class="lineno">15 </span>            <span class="kd">let</span> <span class="p">(</span><span class="n">dref</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">dbRefWithKey</span><span class="p">(</span><span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="n">users</span><span class="p">,</span> <span class="n">uwUID</span><span class="p">,</span> <span class="n">configs</span><span class="p">],</span>
<span class="lineno">16 </span>                                                <span class="kr">prefix</span><span class="p">:</span> <span class="kr">prefix</span><span class="p">)</span>
<span class="lineno">17 </span>            <span class="n">dref</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">toFirebase</span><span class="p">(),</span>
<span class="lineno">18 </span>                          <span class="n">withCompletionBlock</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="k">in</span>
<span class="lineno">19 </span>                <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="n">observer</span><span class="p">.</span><span class="n">onError</span><span class="p">(</span><span class="n">err</span><span class="p">!)</span> <span class="p">}</span>
<span class="lineno">20 </span>                <span class="k">else</span> <span class="p">{</span> <span class="n">observer</span><span class="p">.</span><span class="n">onNext</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">}</span>
<span class="lineno">21 </span>            <span class="p">})</span>
<span class="lineno">22 </span>            <span class="k">return</span> <span class="n">Disposables</span><span class="p">.</span><span class="n">create</span><span class="p">()</span>
<span class="lineno">23 </span>        <span class="p">}</span>
<span class="lineno">24 </span>    <span class="p">}</span>
<span class="lineno">25 </span><span class="p">}</span></code></pre></figure> <p>It can be seen that promise chaining and observable chaining are similar. It’s the small details of how to arrange the code that takes time to be comfortable. With the reactive code, there were many other ways to accomplish the same result but I took special care to express an example that shows how similar they can be.</p> <p> <figure class="image"><img src="/img/2017-05-15-promises-are-a-bridge-to-reactive/flatmap-modified-marble-diagram.png" alt="Figure 2: Modified marble diagram for flatMap.A source observable is mapped and each transformed element ends up in an observable of observables. These are flattened into a single new observable containing the merged, transformed elements." /> <figcaption><strong>Figure 2: Modified marble diagram for flatMap.</strong> A source observable is mapped and each transformed element ends up in an observable of observables. These are flattened into a single new observable containing the merged, transformed elements.</figcaption> </figure> </p> <h2 id="conclusion-observables-can-chain-just-as-well-as-promises">Conclusion: Observables can chain just as well as Promises</h2> <p>In summary, operation chaining can be accomplished with both promises or observables.</p> <ul> <li>If you choose to use promises, you have to make things you want to chain into promises.</li> <li>If you choose to use observables, you have to make things you want to chain into observables.</li> </ul> <p>Since both are just wrappers around operations in your native language, you can wrap one with the other if needed. I’ve found the occasion to wrap an Observable with a Promise while migrating a project from promises to Rx.</p> <p>The templates for each are illustrated below.</p> <h3 id="promise-chaining-template">Promise chaining template</h3><pre><code>firstly { () -&gt; Promise&lt;T&gt; in
    return somePromiseOfTypeT()
}.then { (result: T) -&gt; Promise&lt;U&gt; in
    return somePromiseOfTypeU(use: result)
}.then { (result: U) -&gt; () in
    // Do something with the result of type U.
}.catch { err in
    // Handle the error.
}
</code></pre><p>Alternatively, if you are willing to accept some rightward creep, the <code>firstly</code> keyword can be dropped.</p><pre><code>return somePromiseOfTypeT().then { (result: T) -&gt; Promise&lt;U&gt; in
   return somePromiseOfTypeU()    
}.then { (result: U) -&gt; () in
   // Do something with the result of type U.
}.catch { err in
   // Handle the error.
}
</code></pre><p>How to handle errors within a promise chain can be problematic. Any error is meant to interrupt execution of the series. The reactive toolset is much more versatile for error handling by being able to handle them where needed. Rx does not force you into a fixed pattern of error handling like the way promises do.</p> <h3 id="observable-chaining-template">Observable chaining template</h3><pre><code>someObservableOfTypeT().flatMap { (result: T) -&gt; Observable&lt;U&gt; in
    return someObservableOfTypeU(use: result)
}.subscribe(onNext: { (result: U) in
    // Do something with the result of type U.
}, onError: { err in
    // Handle the error
}).addDisposableTo(bag)
</code></pre><p>Moving the flatMap operator to the next line with a continuation indent allows maintaining leftward alignment of your operators while emphasizing the source observable. This is a style I prefer with Rx.</p><pre><code>someObservableOfTypeT()
    .flatMap { (result: T) -&gt; Observable&lt;U&gt; in
        return someObservableOfTypeU(use: result) }
    .subscribe(onNext: { (result: U) in
        // Do something with the result of type U.
    }, onError: { err in
        // Handle the error
    }).addDisposableTo(bag)
</code></pre><h3 id="final-words-on-chaining">Final words on chaining</h3> <p>Just like with promise chains where the <code>then</code>s can continue on and on, <code>flatMap</code>s can also be added for any number of returned observables. With Rx, however, the difference is this chaining is a situational occurrence. The reactive toolbox has many other options. Note that I have shown you observable chaining in two different contexts, during creation of an observable and during subscription. If you have enjoyed how promises simplify chained asynchronous operations, you will love the extra control that Rx offers for the same underlying operations.</p> <p>Being on the other side, I find it’s more difficult to get promises to fit every problem as they are less malleable resulting in less options than the reactive tool set. They do fit some problems well, like serverless functions on AWS Lambda in Node.js, but outside of those cases you will battle to get them to do more than linear chaining. While a chain can be the perfect choice, it is unsuitable for the range of complex needs found in more advanced apps. For that, my friends, there is an observable that can be crafted for anything.</p> </div> <ul class="tag_box inline"> <li><i class="icon-folder-open"></i></li> <li><a href="/categories#reactive-programming-ref"> reactive-programming <span>1</span> </a></li> </ul> <ul class="tag_box inline"> <li><i class="icon-tags"></i></li> <li><a href="/tags#swift-ref">swift <span>12</span></a></li> <li><a href="/tags#rxswift-ref">rxswift <span>2</span></a></li> <li><a href="/tags#promisekit-ref">promisekit <span>1</span></a></li> <li><a href="/tags#reactive-programming-ref">reactive-programming <span>2</span></a></li> <li><a href="/tags#rx-ref">rx <span>1</span></a></li> <li><a href="/tags#firebase-ref">firebase <span>3</span></a></li> </ul> <hr> <ul class="pagination"> <li class="prev"><a href="/open-source/2017/03/15/swift-script-for-detecting-silence-in-audio-files" title="A Swift Script for Detecting Silence in Audio Files">&larr; Previous</a></li> <li><a href="/archive">Archive</a></li> <li class="next"><a href="/machine-learning/2018/06/24/python-for-ml" title="Manage Python for Machine Learning on macOS">Next &rarr;</a></li> </ul> <hr> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_developer = 1; var disqus_shortname = 'ikiapps'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a> </div> </div> <hr/> <footer> <div style="float: left; margin-top: 10px; margin-bottom: 45px;"> &copy; 2019 ikiApps LLC</div> <div style="float: right; margin-top: 10px; margin-bottom: 40px;"><a href="/contact" target="_blank">Contact</a></div> <div style="float: left; margin-top: 10px; margin-bottom: 40px;"><hr/></div> </footer> </div> <script src="/assets/themes/bootstrap/resources/bootstrap/js/bootstrap.min.js"></script> </body> </html>
